@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.Extensions.Logging
@using Microsoft.JSInterop
@using MoonCore.Blazor.FlyonUi.Files.View
@using MoonCore.Blazor.FlyonUi.DataTables
@using MoonCore.Blazor.FlyonUi.Files.Manager.Modals
@using MoonCore.Helpers
@using MoonCore.Blazor.FlyonUi.Files.Manager.Partials
@using MoonCore.Blazor.FlyonUi.Files.Manager.Toasts
@using MoonCore.Blazor.FlyonUi.Modals
@using MoonCore.Blazor.FlyonUi.Toasts
@using MoonCore.Blazor.FlyonUi.Components

@inject ModalService ModalService
@inject ToastService ToastService
@inject ILogger<FileManager> Logger
@inject DropHandlerService DropHandlerService

@implements IAsyncDisposable

<FileManagerHeader CurrentPath="@CurrentPath"
                   OnBreadcrumbClick="SetPath"
                   OnHomeClick="@(() => SetPath("/"))"
                   OnRefreshClick="() => FileView.Refresh()"
                   OnNewFileClick="CreateNewFile"
                   OnNewFolderClick="CreateNewDirectory"
                   OnFileSelected="HandleFileUpload"/>

<div class="mt-5">
    <FileView @ref="FileView" Load="Load" ShowDate="true" ShowSize="true" OnClick="OnClick"
              CustomClickLink="CustomClickLink" OnContextMenu="OnContextMenu">
        <ChildContent>
            <DataTableRow TItem="FileEntry" Index="int.MinValue">
                <Template>
                    @if (CurrentPath != "/")
                    {
                        <td @onclick="GoUp" scope="row" colspan="99999"
                            class="py-1.5 px-3 text-left font-normal cursor-pointer">
                            <div class="flex flex-row items-center">
                                <i class="icon-folder-up text-accent text-2xl me-5"></i>
                                <div>Go up</div>
                            </div>
                        </td>
                    }
                </Template>
            </DataTableRow>

            <Selection TItem="FileEntry" OnSelectionChanged="OnSelectionChanged"/>
            <DataTableColumn TItem="FileEntry" Index="int.MaxValue">
                <ColumnTemplate>
                    <div class="flex justify-end me-1.5">
                        <a href="#" @onclick="e => OnContextMenu(e.ClientX - 215, e.ClientY, context)" @onclick:preventDefault @onclick:stopPropagation>
                            <i class="icon-ellipsis text-lg"></i>
                        </a>
                    </div>
                </ColumnTemplate>
            </DataTableColumn>
        </ChildContent>
    </FileView>
</div>

<ContextMenu @ref="ContextMenu">
    <button type="button" class="dropdown-item">
        <i class="icon-cloud-download text-primary text-lg"></i>
        Download
    </button>
    <button type="button" class="dropdown-item">
        <i class="icon-folder-archive text-warning text-lg"></i>
        Archive
    </button>
    <button type="button" class="dropdown-item">
        <i class="icon-folder-pen text-accent text-lg"></i>
        Rename
    </button>
    <button type="button" class="dropdown-item">
        <i class="icon-trash-2 text-error text-lg"></i>
        Delete
    </button>
</ContextMenu>

@code
{
    [Parameter] public IFileAccess FileAccess { get; set; }
    [Parameter] public long UploadLimit { get; set; } = -1;

    private string CurrentPath = "/";
    private FileView FileView;

    private ContextMenu ContextMenu;

    protected override void OnInitialized()
    {
        DropHandlerService.OnDropped += HandleFileDrop;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if(!firstRender)
            return;

        await DropHandlerService.Enable();
    }

    private async Task<FileEntry[]> Load()
    {
        var items = await FileAccess.List(CurrentPath);

        return items
            .OrderByDescending(x => x.IsFolder)
            .ThenBy(x => x.Name)
            .ToArray();
    }

    private async Task OnClick(FileEntry fileEntry)
    {
        if (fileEntry.IsFolder)
        {
            CurrentPath = UnixPath.Combine(CurrentPath, fileEntry.Name);

            await FileView.Refresh();
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task GoUp()
    {
        CurrentPath = UnixPath.GetFullPath(
            UnixPath.Combine(CurrentPath, "..")
        );

        await FileView.Refresh();
    }

    private string CustomClickLink(FileEntry arg) => $"/files?path=/{arg.Name}";

    private Task OnSelectionChanged(FileEntry[] arg)
    {
        return Task.CompletedTask;
    }

    private async Task SetPath(string path)
    {
        CurrentPath = path;

        await FileView.Refresh();
        await InvokeAsync(StateHasChanged);
    }

    private async Task CreateNewFile()
    {
        await ModalService.Launch<CreateFileModal>(parameters =>
        {
            parameters.Add("OnSubmit", async (string fileName) =>
            {
                await FileAccess.CreateFile(UnixPath.Combine(
                    CurrentPath,
                    fileName
                ));

                await FileView.Refresh();
            });
        });
    }

    private async Task CreateNewDirectory()
    {
        await ModalService.Launch<CreateDirectoryModal>(parameters =>
        {
            parameters.Add("OnSubmit", async (string name) =>
            {
                await FileAccess.CreateDirectory(UnixPath.Combine(
                    CurrentPath,
                    name
                ));

                await FileView.Refresh();
            });
        });
    }

    private async Task HandleFileUpload(IBrowserFile[] files)
    {
        await ToastService.Launch<FileUploadToast>(parameters =>
        {
            parameters["Callback"] = async (FileUploadToast toast) =>
            {
                // We need this as the upload can run while the file manager is used to navigate elsewhere
                var pwdAtUpload = new string(CurrentPath);

                var failed = 0;
                var succeeded = 0;

                foreach (var file in files)
                {
                    if (UploadLimit != -1 && file.Size > UploadLimit)
                    {
                        await ToastService.Warning($"Unable to upload file as it exceeds the file upload limit: {file.Name}");
                        continue;
                    }

                    await toast.UpdateStatus(file.Name, 0);

                    try
                    {
                        await using var dataStream = file.OpenReadStream(
                            UploadLimit == -1
                                ? file.Size
                                : UploadLimit
                        );

                        await FileAccess.Upload(
                            UnixPath.Combine(pwdAtUpload, file.Name),
                            dataStream,
                            async percent =>
                            {
                                await toast.UpdateStatus(file.Name, percent);
                            }
                        );

                        succeeded++;
                    }
                    catch (Exception e)
                    {
                        Logger.LogError(
                            "An unhandled error occured while uploading file {name}: {e}",
                            file.Name,
                            e
                        );

                        await ToastService.Error(
                            "An error occured while uploading file",
                            file.Name
                        );

                        failed++;
                    }
                }

                await ToastService.Info(
                    "File upload completed",
                    $"Successful: {succeeded} - Failed: {failed}"
                );
                
                await FileView.Refresh();
            };
        });
    }
    
    private async Task HandleFileDrop()
    {
        await ToastService.Launch<FileUploadToast>(parameters =>
        {
            parameters["Callback"] = async (FileUploadToast toast) =>
            {
                // We need this as the upload can run while the file manager is used to navigate elsewhere
                var pwdAtUpload = new string(CurrentPath);

                var failed = 0;
                var succeeded = 0;
                
                var isFirstPeek = true;
                
                do
                {
                    var item = await DropHandlerService.PeekItem();

                    if (isFirstPeek)
                    {
                        if (item == null)
                        {
                            await ToastService.Error(
                                "Unable to handle dropped files and/or folders. Please try again"
                            );
                    
                            return;
                        }
                        else
                            isFirstPeek = false;
                    }
            
                    if(item == null)
                        break;

                    if (item.ShouldSkipToNext)
                    {
                        await DropHandlerService.PopItem();
                        continue;
                    }
            
                    if (UploadLimit != -1 && item.Stream.Length > UploadLimit)
                    {
                        await ToastService.Warning($"Unable to upload file as it exceeds the file upload limit: {UnixPath.GetFileName(item.Path)}");
                        await DropHandlerService.PopItem();
                        continue;
                    }

                    var fileName = UnixPath.GetFileName(item.Path);
                    
                    await toast.UpdateStatus(fileName, 0);

                    try
                    {
                        await using var dataStream = await item.Stream.OpenReadStreamAsync(
                            UploadLimit == -1
                                ? item.Stream.Length
                                : UploadLimit
                        );

                        await FileAccess.Upload(
                            UnixPath.Combine(pwdAtUpload, item.Path),
                            dataStream,
                            async percent => { await toast.UpdateStatus(fileName, percent); }
                        );

                        succeeded++;
                    }
                    catch (Exception e)
                    {
                        Logger.LogError(
                            "An unhandled error occured while uploading file {name}: {e}",
                            fileName,
                            e
                        );

                        await ToastService.Error(
                            "An error occured while uploading file",
                            fileName
                        );

                        failed++;
                    }
                    finally
                    {
                        await DropHandlerService.PopItem();
                    }
                } while (true);

                await ToastService.Info(
                    "File upload completed",
                    $"Successful: {succeeded} - Failed: {failed}"
                );

                await FileView.Refresh();
            };
        });
    }

    public async ValueTask DisposeAsync()
    {
        DropHandlerService.OnDropped -= HandleFileDrop;
        
        try
        {
            await DropHandlerService.Disable();
        }
        catch (JSException)
        {
            // Ignored
        }
    }

    private async Task OnContextMenu(MouseEventArgs mouseEvent, FileEntry entry)
    {
        await ContextMenu.Trigger(mouseEvent);
    }
    
    private async Task OnContextMenu(double x, double y, FileEntry entry)
    {
        await ContextMenu.Trigger(x, y);
    }
}
