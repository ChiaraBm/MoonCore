@using System.ComponentModel.DataAnnotations
@using Microsoft.Extensions.Logging
@using MoonCore.Blazor.FlyonUi.Exceptions
@using MoonCore.Exceptions

@inject ILogger<HandleForm> Logger
@inject GlobalErrorService ErrorService

@if (SubmitException != null)
{
    <div class="flex justify-center items-center">
        <ErrorStateDisplay Exception="SubmitException">
            <button @onclick="ReturnToFormAsync" class="btn btn-sm btn-primary mt-2">
                <i class="icon-undo-2"></i>
                Return
            </button>
        </ErrorStateDisplay>
    </div>
}
else
{
    if (ErrorMessages.Count > 0)
    {
        <div>
            @if (ErrorMessages.Count == 1)
            {
                <div class="alert alert-error flex items-center gap-4 text-sm @ErrorMessageCss" role="alert">
                    <i class="icon-triangle-alert shrink-0 text-lg"></i>
                    <p>@ErrorMessages[0]</p>
                </div>
            }
            else if (ErrorMessages.Count > 1)
            {
                <div class="alert alert-error flex items-start gap-4 @ErrorMessageCss">
                    <span class="icon-triangle-alert text-lg"></span>
                    <div class="flex flex-col gap-1">
                        <h5 class="text-base font-semibold">Error(s) occured while processing your data</h5>
                        <ul class="mt-1.5 list-inside list-disc text-sm">
                            @foreach (var message in ErrorMessages)
                            {
                                <li>@message</li>
                            }
                        </ul>
                    </div>
                </div>
            }
        </div>
    }

    <form action="#" @onsubmit="SubmitAsync" @onsubmit:preventDefault>
        @ChildContent.Invoke(this)
    </form>
}

@code
{
    /// <summary>
    /// Content of the form. Put your fields etc here
    /// </summary>
    [Parameter] public RenderFragment<HandleForm> ChildContent { get; set; }
    
    /// <summary>
    /// Form model to validate on. Use Data Attributes for validation
    /// </summary>
    [Parameter] public required object Model { get; set; }
    
    /// <summary>
    /// Callback when the form is submitted and valid. Any exceptions thrown inside the callback will be handled.
    /// Use a <see cref="DisplayException"/> to display a message
    /// </summary>
    [Parameter] public required EventCallback OnValidSubmit { get; set; }

    /// <summary>
    /// Allows to specify custom css classes for the error message. By default, it contains the spacing class <b>mb-5</b>
    /// </summary>
    [Parameter]
    public string ErrorMessageCss { get; set; } = "mb-5";

    /// <summary>
    /// Determines if the HandleForm is currently submitting
    /// </summary>
    public bool IsSubmitting { get; set; } = false;

    private Exception? SubmitException;
    private readonly List<string> ErrorMessages = [];

    /// <summary>
    /// Triggers submit of the form. Will validate the form and invoke <see cref="OnValidSubmit"/> if valid
    /// </summary>
    /// <returns>True if validated successfully, false if any validation errors occured</returns>
    public async Task<bool> SubmitAsync()
    {
        // Prevent multiple submits at the same time
        if (IsSubmitting)
            return false;

        // Resetting state
        SubmitException = null;
        ErrorMessages.Clear();
        IsSubmitting = true;

        await InvokeAsync(StateHasChanged);

        var wasSuccessful = await InternalSubmitAsync();

        IsSubmitting = false;
        await InvokeAsync(StateHasChanged);

        return wasSuccessful;
    }

    private async Task<bool> InternalSubmitAsync()
    {
        // Exit early if form model is invalid
        if (!ValidateFormModel())
            return false;

        try
        {
            await OnValidSubmit.InvokeAsync();
            return true;
        }
        catch (Exception e)
        {
            if (e is DisplayException displayException)
            {
                ErrorMessages.Add(displayException.Message);
                return false;
            }
            else if (e is HttpApiException httpApiException)
            {
                // Pass through unauthenticated exception to parents
                // as we don't want to handle them
                if (httpApiException.Status == 401)
                {
                    await ErrorService.HandleExceptionAsync(e);
                    SubmitException = e;
                    return false;
                }

                // We only want to create error messages of responses
                // which are of the type "BadRequest". All other
                // status codes should be handled by our error state display
                if (httpApiException.Status != 400)
                {
                    SubmitException = e;
                    return false;
                }

                // If no form errors are specified we want to create an
                // error message out of the base problem details
                if (httpApiException.Errors == null || httpApiException.Errors.Count == 0)
                {
                    ErrorMessages.Add(
                        string.IsNullOrEmpty(httpApiException.Detail) ? httpApiException.Title : httpApiException.Title + ": " + httpApiException.Detail
                    );

                    return false;
                }

                // Create text error messages out of the problem details errors
                ErrorMessages.AddRange(httpApiException.Errors
                    .Select(x => $"{x.Key}: {string.Join(", ", x.Value)}")
                );

                return false;
            }
            else
            {
                Logger.LogError(e, "An unhandled error occured while handling form");

                SubmitException = e;
                return false;
            }
        }
    }

    private async Task ReturnToFormAsync()
    {
        SubmitException = null;
        await InvokeAsync(StateHasChanged);
    }

    private bool ValidateFormModel()
    {
        var context = new ValidationContext(Model, null, null);
        var results = new List<ValidationResult>();

        if (Validator.TryValidateObject(Model, context, results, true))
            return true;

        ErrorMessages.AddRange(
            results
                .Select(x => $"{string.Join(", ", x.MemberNames)}: {x.ErrorMessage}")
        );

        return false;
    }
}