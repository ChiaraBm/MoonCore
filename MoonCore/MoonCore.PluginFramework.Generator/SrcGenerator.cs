using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MoonCore.PluginFramework.Generator;

[Generator]
public class SrcGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) =>
                    node is ClassDeclarationSyntax cds &&
                    cds.AttributeLists.Count > 0, // Only handle classes which have attributes
                transform: (ctx, _) =>
                {
                    var classSyntax = (ClassDeclarationSyntax)ctx.Node;
                    var model = ctx.SemanticModel;
                    var symbol = model.GetDeclaredSymbol(classSyntax);
                    return symbol;
                })
            .Where(symbol =>
            {
                if (symbol == null)
                    return false;
                
                return symbol.GetAttributes().Any(attr =>
                    attr.AttributeClass?.Name == "PluginLoaderAttribute" ||
                    attr.AttributeClass?.ContainingNamespace.ToDisplayString() == "MoonCore.PluginFramework"
                );
            });

        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses, (spc, source) =>
        {
            var (compilation, classes) = source;

            foreach (var lcSymbol in classes)
            {
                // Handle invalid symbols
                if(lcSymbol is not INamedTypeSymbol loaderClass)
                    continue;
                
                // Try to find the interface the loader uses
                var interfaceType = loaderClass.Interfaces.FirstOrDefault();
                if (interfaceType == null) continue;

                var allImplementations = new List<INamedTypeSymbol>();
                
                foreach (var tree in compilation.SyntaxTrees)
                {
                    var semanticModel = compilation.GetSemanticModel(tree);
                    
                    var classNodes = tree
                        .GetRoot()
                        .DescendantNodes()
                        .OfType<ClassDeclarationSyntax>();

                    foreach (var classNode in classNodes)
                    {
                        var symbol = semanticModel.GetDeclaredSymbol(classNode) as INamedTypeSymbol;
                        
                        // Dont handle invalid symbols
                        if(symbol == null)
                            continue;

                        // Ignore the loader class itself
                        if (SymbolEqualityComparer.Default.Equals(symbol, loaderClass))
                            continue;
                        
                        // If the class doesn't implement the interface we want to continue 
                        if(!symbol.AllInterfaces.Contains(interfaceType, SymbolEqualityComparer.Default))
                            continue;
                        
                        allImplementations.Add(symbol);
                    }
                }

                // Now we can finally generate the classes
                var sourceText = GeneratePartialClass(loaderClass, interfaceType, allImplementations);
                spc.AddSource($"{loaderClass.Name}_PluginLoader.g.cs", SourceText.From(sourceText, Encoding.UTF8));
            }
        });
    }

    private static string GeneratePartialClass(INamedTypeSymbol loaderClass, INamedTypeSymbol interfaceType, List<INamedTypeSymbol> implementations)
    {
        var ns = loaderClass.ContainingNamespace.ToDisplayString();
        var className = loaderClass.Name;
        var interfaceName = interfaceType.ToDisplayString();
        
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine($"namespace {ns}");
        sb.AppendLine("{");
        sb.AppendLine($"    public partial class {className}");
        
        // Declare the instances
        
        sb.AppendLine("    {");
        sb.AppendLine($"        private {interfaceName}[] Instances;");
        
        // Create references to them when initializing
        
        sb.AppendLine($"        public void Initialize()");
        sb.AppendLine("        {");
        sb.AppendLine($"            Instances = new {interfaceName}[]");
        sb.AppendLine("            {");

        foreach (var impl in implementations.Distinct(SymbolEqualityComparer.Default))
        {
            sb.AppendLine($"                new {impl.ToDisplayString()}(),");
        }

        sb.AppendLine("            };");
        sb.AppendLine("        }");
        
        // Now we want to implement all the interface methods in our partial class and proxy them to all instances

        foreach (var method in interfaceType.GetMembers().OfType<IMethodSymbol>())
        {
            if (method.MethodKind != MethodKind.Ordinary)
                continue;

            var returnType = method.ReturnType.ToDisplayString();
            var methodName = method.Name;
            var parameters = string.Join(", ", method.Parameters.Select(p => $"{p.Type.ToDisplayString()} {p.Name}"));
            var args = string.Join(", ", method.Parameters.Select(p => p.Name));

            
            if(returnType == "System.Threading.Tasks.Task")
                sb.AppendLine($"        public async {returnType} {methodName}({parameters})");
            else
                sb.AppendLine($"        public {returnType} {methodName}({parameters})");
            
            sb.AppendLine("        {");

            if (returnType != "void" && returnType != "System.Threading.Tasks.Task")
            {
                sb.AppendLine($"            {returnType} result = default;");
            }

            sb.AppendLine("            foreach (var instance in Instances)");
            sb.AppendLine("            {");

            if (returnType != "void")
            {
                if(returnType == "System.Threading.Tasks.Task")
                    sb.AppendLine($"                await instance.{methodName}({args});");
                else
                    sb.AppendLine($"                result = instance.{methodName}({args});");
            }
            else
                sb.AppendLine($"                instance.{methodName}({args});");

            sb.AppendLine("            }");

            if (returnType != "void" && returnType != "System.Threading.Tasks.Task")
                sb.AppendLine("            return result;");

            sb.AppendLine("        }");
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }
}