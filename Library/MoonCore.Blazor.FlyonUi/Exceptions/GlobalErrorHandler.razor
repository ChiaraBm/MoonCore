@using Microsoft.Extensions.Logging
@using MoonCore.Blazor.FlyonUi.Components
@using MoonCore.Blazor.FlyonUi.Toasts
@using MoonCore.Helpers

@inject GlobalErrorService GlobalErrorService
@inject ToastService ToastService
@inject NavigationManager Navigation

@inherits ErrorBoundaryBase
@implements IDisposable

@if (ShouldShowException)
{
    <ErrorStateDisplay Exception="Exception">
        @if (ExceptionIsRecoverable)
        {
            <div class="mt-3.5">
                <button @onclick="RecoverExceptionAsync" type="button" class="btn btn-sm btn-primary">
                    Go back
                </button>
            </div>
        }
    </ErrorStateDisplay>
}
else
{
    if (ShouldShowMessage)
    {
        <div class="alert alert-error text-error-content flex items-center gap-4 mb-5">
            <span class="@MessageIcon shrink-0 text-lg"></span>
            <div class="flex flex-col gap-1">
                <h5 class="text-lg font-semibold">
                    @MessageTitle
                </h5>
                <p>
                    @MessageContent
                </p>
            </div>
            <button @onclick="DismissMessageAsync" type="button" class="ms-auto cursor-pointer leading-none">
                <span class="icon-x text-lg"></span>
            </button>
        </div>
    }

    @ChildContent
}

@code
{
    private IDisposable? NavigationManagerSubscription;

    // Message
    private bool ShouldShowMessage = false;
    private string MessageContent;
    private string MessageTitle;
    private string MessageIcon;
    private readonly Debouncer MessageDebouncer = new(TimeSpan.FromSeconds(3));

    // Exception
    private bool ShouldShowException = false;
    private string ExceptionTitle;
    private bool ExceptionIsRecoverable;
    private Exception Exception;

    protected override void OnInitialized()
    {
        NavigationManagerSubscription = Navigation.RegisterLocationChangingHandler(async context =>
        {
            if (!ShouldShowMessage && !(ShouldShowException && ExceptionIsRecoverable))
                return;

            if (ShouldShowMessage)
                ShouldShowMessage = false;

            if (ShouldShowException && ExceptionIsRecoverable)
                ShouldShowException = false;

            await InvokeAsync(StateHasChanged);
        });
        
        GlobalErrorService.SetHandler(this);
    }

    internal async Task HandleExceptionAsync(Exception ex, string title, bool isBlocking, bool isRecoverable)
    {
        if (!isBlocking)
        {
            await ToastService.ErrorAsync(
                title,
                ex.Message
            );
            
            return;
        }

        ShouldShowException = true;
        Exception = ex;
        ExceptionTitle = title;
        ExceptionIsRecoverable = isRecoverable;

        await InvokeAsync(StateHasChanged);
    }

    internal async Task ShowMessageAsync(string title, string message, string icon)
    {
        MessageTitle = title;
        MessageContent = message;
        MessageIcon = icon;

        ShouldShowMessage = true;
        await InvokeAsync(StateHasChanged);
        
        MessageDebouncer.Debounce(async () =>
        {
            ShouldShowMessage = false;
            await InvokeAsync(StateHasChanged);
        });
    }

    private async Task DismissMessageAsync()
    {
        ShouldShowMessage = false;
        await InvokeAsync(StateHasChanged);
    }

    private async Task RecoverExceptionAsync()
    {
        ShouldShowException = false;
        await InvokeAsync(StateHasChanged);
    }

    protected override async Task OnErrorAsync(Exception exception)
    {
        await GlobalErrorService.HandleExceptionAsync(exception, string.Empty, true);
        Recover();
    }
    
    public void Dispose()
    {
        NavigationManagerSubscription?.Dispose();
    }
}
