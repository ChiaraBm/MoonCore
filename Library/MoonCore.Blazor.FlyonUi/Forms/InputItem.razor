@using Microsoft.AspNetCore.Components.Web.Virtualization
@using MoonCore.Blazor.FlyonUi.Common
@using MoonCore.Blazor.FlyonUi.Components
@using MoonCore.Common
@using MoonCore.Helpers

@typeparam TItem

<div class="advance-select relative active">
    <button @onclick="ToggleVisibilityAsync" type="button" aria-expanded="true"
            class="advance-select-toggle">
        @if (Value == null)
        {
            <span class="truncate">
                Select option...
            </span>
        }
        else
        {
            <span class="truncate">
                @DisplayField.Invoke(Value)
            </span>
        }
    </button>

    @if (IsVisible)
    {
        <div
            class="absolute advance-select-menu opened top-full mt-3 z-70 max-h-52 overflow-y-auto overscroll-contain bg-base-200! shadow-lg"
            role="listbox" tabindex="-1"
            aria-orientation="vertical">

            @if (ItemSource.IsFilterable)
            {
                <div class="bg-base-200 sticky top-0 border-b-2 border-b-base-content/20">
                    <input @oninput="OnSearchInput" value="@SearchTerm"
                           type="text" placeholder="Search..."
                           class="bg-transparent placeholder-base-content/60 w-full h-10 px-4 focus:outline-none">
                </div>
            }

            @if (IsLoading)
            {
                <div class="flex justify-center items-center my-5">
                    <Spinner/>
                </div>
            }

            <Virtualize @ref="VirtualizeHandle"
                        Context="item"
                        TItem="TItem"
                        MaxItemCount="MaxItems"
                        ItemsProvider="LoadItemsInternalAsync"
                        ItemSize="44">
                <Placeholder>
                    <div tabindex="0"
                         class="cursor-progress advance-select-option disabled">
                        <div class="flex flex-row justify-start items-center w-full">
                            <div class="italic">
                                Loading
                            </div>
                        </div>
                    </div>
                </Placeholder>
                <EmptyContent>
                    <div class="flex items-center justify-center pt-2 pb-1">
                        <span class="text-base-content/80">No items found</span>
                    </div>
                </EmptyContent>
                <ItemContent>
                    @{
                        var isSelected = item?.Equals(Value) ?? false;
                    }
                    
                    <div @onclick="() => SelectAsync(item)"
                         tabindex="0"
                         class="cursor-pointer advance-select-option selected:select-active @(isSelected ? "selected" : "")">
                        @if (isSelected)
                        {
                            <div class="flex flex-row justify-between items-center w-full">
                                <div class="truncate">
                                    @DisplayField.Invoke(item)
                                </div>
                                <div>
                                    <i class="icon-check text-base text-primary-content"></i>
                                </div>
                            </div>
                        }
                        else
                        {
                            <div class="flex flex-row justify-start items-center w-full">
                                <div class="truncate">
                                    @DisplayField.Invoke(item)
                                </div>
                            </div>
                        }
                    </div>
                </ItemContent>
            </Virtualize>
        </div>

        <div @onclick="OnFocusOut"
             class="overlay-backdrop transition duration-300 fixed inset-0 overflow-y-auto z-69"></div>
    }

    <i class="icon-chevrons-up-down text-base-content absolute top-1/2 end-3 -translate-y-1/2"></i>
</div>

@code
{

    #region Binder

    /// <summary>
    /// Current value of the <see cref="InputItem{TItem}"/>
    /// </summary>
    [Parameter]
    public TItem? Value
    {
        get => InnerValue;
        set
        {
            if (InnerValue == null && value == null)
                return;

            if (InnerValue?.Equals(value) ?? false)
                return;

            InnerValue = value;
            ValueChanged.InvokeAsync(value);
        }
    }

    /// <summary>
    /// <b>Optional:</b> Callback which gets executed when the <see cref="Value"/> has changed
    /// </summary>
    [Parameter]
    public EventCallback<TItem?> ValueChanged { get; set; }

    private TItem? InnerValue;

    #endregion

    /// <summary>
    /// ItemSource to retrieve the items to display from.
    /// Supports filtering (and pagination when filtering)
    /// </summary>
    [Parameter]
    public required ItemSource<TItem> ItemSource { get; set; }


    /// <summary>
    /// Maximum amount of items to load and show within the viewport.
    /// Is limited due to the fixed height of the popup container
    /// </summary>
    [Parameter] public int MaxItems { get; set; } = 25;

    /// <summary>
    /// Define which field should be used to display the item in the dropdown.
    /// This expression can also build a string to combine multiple properties
    /// <br />
    /// <br />
    /// Example:
    /// <code>
    /// DisplayField="@(x => $"{x.FirstName} {x.LastName}")"
    /// </code>
    /// </summary>
    [Parameter]
    public required Func<TItem, object> DisplayField { get; set; }

    /// <summary>
    /// Debounce time of the search field in milliseconds. Used to limit the amount of times
    /// the component invokes the item source
    /// </summary>
    [Parameter] public int SearchDebounceMs { get; set; } = 50;

    /// <summary>
    /// Specifies whether clicking on the same option will deselect the item
    /// and sets the current value to null
    /// </summary>
    [Parameter] public bool AllowDeselect { get; set; } = true;

    private bool IsVisible;
    private bool IsLoading = true;
    private string SearchTerm;
    private Debouncer SearchDebouncer;
    private Virtualize<TItem> VirtualizeHandle;

    protected override void OnInitialized()
    {
        SearchDebouncer = new(SearchDebounceMs);
    }
    
    private async ValueTask<ItemsProviderResult<TItem>> LoadItemsInternalAsync(ItemsProviderRequest request)
    {
        var response = await ItemSource.QueryAsync(request.StartIndex, request.Count, SearchTerm, null);

        if (IsLoading)
        {
            IsLoading = false;
            await InvokeAsync(StateHasChanged);
        }

        // Early exit for pre counted data
        if (response is CountedData<TItem> countedData)
            return new ItemsProviderResult<TItem>(countedData.Items, countedData.TotalCount);

        // We are creating the array here as if we would use Count() it may enumerate multiple times
        var data = response.ToArray();

        var items = data.Skip(request.StartIndex).Take(request.Count);

        return new ItemsProviderResult<TItem>(items, data.Length);
    }

    private async Task SelectAsync(TItem item)
    {
        if(!AllowDeselect && (Value?.Equals(item) ?? false))
            return;
        
        if (Value?.Equals(item) ?? false) // Deselect using click on the same item again
            Value = default;
        else
            Value = item;

        IsVisible = false;
        await InvokeAsync(StateHasChanged);
    }
    
    private async Task OnFocusOut()
    {
        IsVisible = false;
        await InvokeAsync(StateHasChanged);
    }

    private async Task ToggleVisibilityAsync()
    {
        SearchTerm = "";
        IsLoading = true;
        IsVisible = !IsVisible;
        await InvokeAsync(StateHasChanged);
    }

    private Task OnSearchInput(ChangeEventArgs eventArgs)
    {
        SearchTerm = eventArgs.Value?.ToString() ?? "";
        
        SearchDebouncer.Debounce(async () =>
        {
            await VirtualizeHandle.RefreshDataAsync();
            await InvokeAsync(StateHasChanged);
        });
        
        return Task.CompletedTask;
    }
}